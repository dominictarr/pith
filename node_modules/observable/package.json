{
  "name": "observable",
  "version": "2.1.0",
  "homepage": "https://github.com/dominictarr/observable",
  "repository": {
    "type": "git",
    "url": "git://github.com/dominictarr/observable.git"
  },
  "devDependencies": {
    "hyperscript": "~1.0.1",
    "tape": "~0.2.2"
  },
  "scripts": {
    "test": "set -e; for t in test/*.js; do node $t; done"
  },
  "author": {
    "name": "Dominic Tarr",
    "email": "dominic.tarr@gmail.com",
    "url": "http://dominictarr.com"
  },
  "license": "MIT",
  "readme": "# observable\n\nA function as representation of a trackable mutable value.\n\n[Interactive Demo](http://dominictarr.github.com/observable)\n\nIt's basically just a `function` that can be called in 3 ways,\nIf an observable is called with no arguments `f()`, it returns the current value.\nIf it is called with an argument `f(value)`, it set that as the value.\n\n``` js\nvar o = require('observable')\nvar v = o()\n\n//set the value\nv(Math.random())\n\n//get the value\nv()\n```\n\nAnd, finally, if an observable is called with another function, \n`f(function (v) {...})`, it _calls_ that function with the new value, \nwhenever the value changes.\n\n## value\n\n``` js\nvar o = require('observable')\nvar v = o()\n\nv(0)\n\nsetInterval(function () {\n  v(v() + 1)\n}, 500)\n\nv\n```\n\nHow is this demo updating in real-time like that?\nIt's because `observable` is integrated into \n[hyperscript](https://github.com/dominictarr/hyperscript)!\n\n## input, & transform\n\nobserve a input field, and transform it into different string.\nthis transformation is a one way observable.\n\n``` js\nvar o = require('observable')\nvar h = require('hyperscript')\nvar yourName\n  \nh('div', \n  h('h3', 'hello, what is your name?',\n    yourName = h('input', {placeholder: 'enter name'})\n  ),\n  h('h2', o.transform(o.input(yourName), function (v) {\n    return v ? 'Happy Birthday ' + v.toUpperCase() + ' !!!': ''\n  }), {style: {'font-family': 'Comic Sans MS'}})\n)\n```\n\nOh, wow! wasn't that easy! and we did a lot of things there!\n\n* made hyper text that updated in realtime\n* read from an input as you typed\n* transformed user input\n\nAnd there is many other cool things we can do to!\n\n# not\n\nInvert a boolean `observable`\n\n``` js\nvar o = require('observable')\nvar h = require('hyperscript')\nvar _i, i\nh('div',\n  _i = h('input', {type: 'checkbox'}),\n  'checked:', i = o.input(_i, 'checked', 'change'),\n  ' !checked:', o.not(i)\n)\n```\n\nHmm, I wonder if we could couple two things interms of each other?\n\n``` js\nvar o = require('observable')\nvar h = require('hyperscript')\nvar _i = h('input', {type: 'checkbox'})\nvar _j = h('input', {type: 'checkbox'})\nvar i = o.input(_i, 'checked', 'change')\nvar j = o.input(_j, 'checked', 'change')\n\n//just make i != j & j != i\ni(Math.random() < 0.5)\n\no.bind2(o.not(i), j)\n\nh('div', _i, _j)\n```\n\n## compute\n\nCompute a value from others, like a computed value in SQL.\n\n``` js\nvar o = require('observable')\nvar h = require('hyperscript')\nvar i, j\nh('div', \n  i = h('input', {placeholder: 'first name'}),\n  j = h('input', {placeholder: 'last name'}),\n  h('h1', 'Greetings, ',\n    o.compute([o.input(i), o.input(j)], function (f, l) {\n      return f + ' ' + l + (f && l ? ' !' : '')\n    })\n  )\n)\n```\n\n## hover & focus\n\n``` js\nvar h = require('hyperscript')\nvar o = require('observable')\n\nh('div', \n  strong = h('strong', {\n      contentEditable: true,\n      style:{display: 'inline-block'}\n    }, \n    \"editable thing\"\n  ),\n  h('ul', \n    h('li', 'focus: ', o.focus(strong)), \n    h('li', 'hover: ', o.hover(strong))\n  )\n)\n```\n\n## signal \n\nLike observable except only update listeners when the value actually changes.\n\n``` js\nvar s = require('observable').signal\n```\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "_id": "observable@2.1.0",
  "description": "A function as representation of a trackable mutable value.",
  "_from": "observable@"
}
