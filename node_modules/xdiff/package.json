{
  "author": {
    "name": "Dominic Tarr",
    "email": "dominic.tarr@gmail.com",
    "url": "dominictarr.com"
  },
  "name": "xdiff",
  "description": "calc diffs of complex javascript objects.",
  "version": "0.2.11",
  "homepage": "http://github.com/dominictarr/xdiff",
  "repository": {
    "url": "git://github.com/dominictarr/xdiff.git"
  },
  "engines": {
    "node": "*"
  },
  "dependencies": {
    "adiff": "~0.2.4"
  },
  "devDependencies": {},
  "optionalDependencies": {},
  "readme": "# xdiff\n\n`diff`, `diff3`, `patch` (nearly) arbitary json documents.\n\n## examples\n\n``` js\nvar x = require('xdiff')\n\nvar a = SOMEOBJECT\nvar b = SOMEOBJECT_AFTER_CHANGES\n\nvar diff = x.diff(a, b)\n\n// can apply a diff to A to get B\n\nvar patched = x.patch(a, diff)\n\nrequire('assert').deepEqual(a, patched)\n\n```\n\n## diff, patch, diff3\n\nwith `diff` you can create a diff that is applyable with `patch`\nyou can diff nested objects, and arrays.\n\nwith `diff3` you create a diff from two objects that have been edited concurrently, \nyou need to also to pass the [concestor](http://en.wikipedia.org/wiki/Concestor).\n\nalso see [adiff](https://github.com/dominictarr/adiff] which xdiff depends on to diff arrays.\n\nxdiff is compatible with [snob](https://github.com/dominictarr/snob)\n\n### Objects\n\n``` js\nvar a = {a: true, c: 'deleteme'}\nvar b = {a: true, b: false}\nvar p = x.diff(a, b)\n```\n\nwill create a diff like this:\n\n``` js\n[ ['set', ['root', 'b'], false]\n, ['del', ['root', 'c']] ]\n```\n\noperations on nested objects are represented by thier path, \nunless the object has an ID. (see below)\n\n``` js\nvar a0 = {A: {AA: '?'}}\nvar a1 = {A: {AA: 'aardvark'}}\nvar p = x.diff(a, b)\n```\n\nwill create diff like this:\n\n``` js\n [['set', ['root', 'A', 'AA'], 'aardvark']]\n```\n\n## Arrays\n\n``` js\nvar a = [1, 2 , 3]\nvar b = [0, 1, 'hello', 3]\nvar p = x.diff(a, b)\n```\n\nwill create a diff like\n\n``` js\n\n[ 'splice', ['root'], [\n    [ 1, 1, 'hello] //at index 1 delete one item and insert hello\n  , [ 0, 0, 0]      //at index 0 delete 0 items and insert `0`\n]\n```\n\n## Objects in Arrays\n\nif you give objects an ID, then xdiff will beable to track it properly, even if it's moved.\neven if it's concurrently changed.\n\n``` js\nvar a = [{__id__: '#1'}, 5, {__id__: '#2'}]\nvar b = [5, {__id__: '#2'}, {__id__: '#1', prop: 'surprise'}]\nvar p = x.diff(a, b)\n```\n\nwill produce a diff like this\n\n``` js\n  [ ['set', ['#1', 'prop'], 'surprise'] //this applies the change to object #1\n  , ['splice', ['root'], [ \n      [ 3, 0, '#=*#1'] //this just updates the reference!\n    , [ 0, 1]\n    ] ]\n  ]\n\n```\nif you don't don't use id's `xdiff` won't know that an object that has changed\nis actually the same object. this would cause it to reinsert a new copy of that object.\n\nid's are this is really useful when you need to do 3-way-merges to merge together concurrent changes.\n\nin a future version, xdiff will allow changing the id key. currently it uses only the `__id__` property.\n\n## 3-way-merge: diff3\n\nthree way merge takes 3 objects, `mine`, `yours` and an `old` object, which must be the [concestor](http://en.wikipedia.org/wiki/Concestor) of both mine and yours.\n\nif there are concurrent changes, xdiff will choose to use the change from `mine`\n\nin a future version, xdiff will support injectable resolve function, so that you can choose how to rosolve the merge.\n\n## licence\n\nMIT / Apache2\n",
  "readmeFilename": "readme.markdown",
  "_id": "xdiff@0.2.11",
  "dist": {
    "shasum": "624f6cf84a0c6654cf6b0c050748c69b50063bb6"
  },
  "_from": "xdiff@",
  "_resolved": "https://registry.npmjs.org/xdiff/-/xdiff-0.2.11.tgz"
}
